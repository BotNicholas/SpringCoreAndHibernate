# Repository
***
Он нужен для прямой работы с данными. Очень похож на __DAO__, но с гораздо большим разнообразием методов.

## Repository implementation

В __Spring__, когда ты создаешь Отдельный интерфейс имплантирующий JPARepository на самом деле это отдельная имплементация.
Просто Spring сам Создаст реализацию и таким образом из интерфейса он превратится в класс. 

В данном случае, я создал только одну generic реализацию репозитория.

# Service
***

В Service указывается дополнительная логика (бизнес логика). Для каждого класса он отдельный!



# Небольшая заметка по @Transactional
***

для того, чтобы работала эта аннотация, нужно либо указать  `<tx:annotation-driven proxy-target-class="false"/>` для __XML__ или `@EnableTransactionManagement`.  

Эта аннотация влечет за собой использование __AOP__ и => использование прокси.

Она как бы говорит, что вот тут, нужно создать транзакционный прокси

Но, так как прокси не могут создаваться сами по себе, нужен ещё и TransactionManager

    ! Сам Spring не создает его реализацию!!! Мы должны это делать сами!!!

То есть можно либо самому управлять транзакциями, либо использовать `@Transactional"`. Однако, для того, чтобы она работала, нужен __TransactionManager__ + ещё нужно включить авто-транзакции (`@EnableTransactionManagement`), так как без него она бесполезна...

Без `@EnableTransactionManagement`:
```java
Exception in thread "main" org.hibernate.HibernateException: Could not obtain transaction-synchronized Session for current thread
```

Прокси создаются Spring-ом на этапе создания бинов, и тогда, когда он видит, что данный класс использует @Transactional. То есть если мы в ручную попытаемся создать такой бин, прокси не создастся, так как это ответственность Spring

Spring анализирует класс и методы на предмет наличия @Transactional. Таким образом он поймёт, что нужно создать прокси


# Стратгии создания прокси
***
__You__

Создание прокси - это создание класса-наследника класса-цели и переопределение методов этого класса-цели, верно?

__ChatGPT__

Создание прокси в Java зависит от используемого метода. 

Есть два основных способа создания прокси:

1. Создание Прокси с использованием __JDK__ (на основе ___интерфейсов___):

* В этом случае, прокси не является физическим наследником класса-цели. \
Вместо этого, он реализует те же интерфейсы, что и целевой объект.
* Прокси-объект создается с помощью __java.lang.reflect.Proxy__ и использует __InvocationHandler__, который определяет, что делать, когда вызываются методы интерфейса.
* В методе __invoke InvocationHandler__, можно реализовать дополнительную логику, которая будет выполнена перед или после вызова соответствующего метода на целевом объекте.

2. Создание Прокси с использованием __CGLIB__ (на основе ___класса___):

* В этом случае, прокси является наследником класса-цели. CGLIB динамически генерирует подкласс целевого класса.
* Методы этого подкласса могут быть переопределены для добавления дополнительной логики (например, для перехвата вызовов методов).
* Этот подход используется, когда нужно создать прокси для классов, которые не реализуют интерфейсы, или когда явно указано использовать проксирование на уровне класса в Spring.
Таким образом, в случае с JDK прокси, создается объект, который реализует те же интерфейсы, но не является наследником класса-цели. В случае с CGLIB, создается подкласс целевого класса, что можно рассматривать как "наследование и переопределение методов".


    * Если Spring, видит, что твой класс - наследник интерфейса, то он использует перавый вариант. Если же нет (на наследник интерфейса), то второй!!
    * Эта логика работает также, если твой класс - наследник класса, реализующего репозиторий (что, в принципе, логично, ведь у наследника в любом случае будут методы родителя)

# @Qualifier - необходимость?

### Вопрос:
> Почему при указании `@Qualifier` __Spring__ понимает, что бин не подходит, но если его убрать, он посчитает, что все бины, имплементирующие __Generic__ интерфейс подходят.
>
> То есть если не указать эту аннотацию, то он посчитает, что для `DefaultRepository<RefContactType, Integer>` подойдет и `DefaultRepository<Author, Integer>` и `DefaultRepository<Book, Integer>` и другие бины, реализующие интерфейс
>
> ```java
> public interface DefaultRepository<T, K> {
>   public List<T> findAll();
>   public T findById(K id);
>   public void save(T obj);
>   public void delete(T obj);
>   public void deleteById(K id);
> }
> ```

### Ответ:
>Когда вы используете __Spring__ для внедрения зависимостей и не указываете аннотацию `@Qualifier`, __Spring__ пытается найти бин, который соответствует требуемому типу. 
> 
> Если указанный тип является __обобщенным интерфейсом__, как в вашем случае с `DefaultRepository<T, K>`, __Spring__ будет искать бины, соответствующие этому интерфейсу, __но без учета конкретных параметров типа (T, K), так как информация о конкретных типах стирается во время выполнения__ (типовое стирание в __Java__).
>
> Если в вашем контексте __Spring__ существует несколько бинов, которые реализуют `DefaultRepository` с различными параметрами типа, и вы не используете `@Qualifier` для указания конкретного бина.



# PlatformTransactionManager

__PlatformTransactionManager__ - основной интерфейс для всех __TransactionManager__-ов __Spring__-а