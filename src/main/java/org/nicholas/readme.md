# Repository
***
Он нужен для прямой работы с данными. Очень похож на __DAO__, но с гораздо большим разнообразием методов.

## Repository implementation

В __Spring__, когда ты создаешь Отдельный интерфейс имплантирующий JPARepository на самом деле это отдельная имплементация.
Просто Spring сам Создаст реализацию и таким образом из интерфейса он превратится в класс. 

В данном случае, я создал только одну generic реализацию репозитория.

# Service
***

В Service указывается дополнительная логика (бизнес логика). Для каждого класса он отдельный!



# Небольшая заметка по @Transactional
***

для того, чтобы работала эта аннотация, нужно либо указать  `<tx:annotation-driven proxy-target-class="false"/>` для __XML__ или `@EnableTransactionManagement`.  

Эта аннотация влечет за собой использование __AOP__ и => использование прокси.

Но, так как прокси не могут создаваться сами по себе, нужен ещё и TransactionManager

    ! Сам Spring не создает его реализацию!!! Мы должны это делать сами!!!




# Стратгии создания прокси
***
__You__

Создание прокси - это создание класса-наследника класса-цели и переопределение методов этого класса-цели, верно?

__ChatGPT__

Создание прокси в Java зависит от используемого метода. 

Есть два основных способа создания прокси:

1. Создание Прокси с использованием __JDK__ (на основе ___интерфейсов___):

* В этом случае, прокси не является физическим наследником класса-цели. \
Вместо этого, он реализует те же интерфейсы, что и целевой объект.
* Прокси-объект создается с помощью __java.lang.reflect.Proxy__ и использует __InvocationHandler__, который определяет, что делать, когда вызываются методы интерфейса.
* В методе __invoke InvocationHandler__, можно реализовать дополнительную логику, которая будет выполнена перед или после вызова соответствующего метода на целевом объекте.

2. Создание Прокси с использованием __CGLIB__ (на основе ___класса___):

* В этом случае, прокси является наследником класса-цели. CGLIB динамически генерирует подкласс целевого класса.
* Методы этого подкласса могут быть переопределены для добавления дополнительной логики (например, для перехвата вызовов методов).
* Этот подход используется, когда нужно создать прокси для классов, которые не реализуют интерфейсы, или когда явно указано использовать проксирование на уровне класса в Spring.
Таким образом, в случае с JDK прокси, создается объект, который реализует те же интерфейсы, но не является наследником класса-цели. В случае с CGLIB, создается подкласс целевого класса, что можно рассматривать как "наследование и переопределение методов".


    ! Если Spring, видит, что твой класс - наследник интерфейса, то он использует перавый вариант. Если же нет (на наследник интерфейса), то второй!!